<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scaling FastAPI for Millions of Records | Vipul Rathod</title>
    <meta name="description" content="How we built a real-time trading analytics backend that processes millions of data records efficiently.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .blog-post {
            min-height: 100vh;
            padding: 120px 0 80px;
        }
        .blog-header {
            text-align: center;
            margin-bottom: 60px;
        }
        .blog-category-tag {
            display: inline-block;
            padding: 8px 20px;
            background: var(--gradient-primary);
            border-radius: 30px;
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
            margin-bottom: 20px;
        }
        .blog-post-title {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            margin-bottom: 20px;
            background: var(--gradient-text);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .blog-meta {
            display: flex;
            justify-content: center;
            gap: 30px;
            color: var(--color-text-secondary);
            font-size: 0.95rem;
        }
        .blog-meta span {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .blog-featured-image {
            width: 100%;
            max-width: 900px;
            margin: 0 auto 60px;
            border-radius: var(--radius-xl);
            overflow: hidden;
            background: var(--gradient-card);
            border: 1px solid var(--color-border);
            aspect-ratio: 16/9;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .blog-featured-image svg {
            width: 120px;
            height: 120px;
            color: var(--color-secondary);
            opacity: 0.5;
        }
        .blog-body {
            max-width: 800px;
            margin: 0 auto;
            font-size: 1.1rem;
            line-height: 1.9;
            color: var(--color-text-secondary);
        }
        .blog-body h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--color-text);
            margin: 50px 0 20px;
        }
        .blog-body h3 {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--color-text);
            margin: 40px 0 15px;
        }
        .blog-body p {
            margin-bottom: 25px;
        }
        .blog-body ul, .blog-body ol {
            margin-bottom: 25px;
            padding-left: 30px;
        }
        .blog-body li {
            margin-bottom: 12px;
        }
        .blog-body code {
            background: rgba(99, 102, 241, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            color: var(--color-primary);
        }
        .blog-body pre {
            background: var(--color-bg-tertiary);
            padding: 25px;
            border-radius: var(--radius-lg);
            overflow-x: auto;
            margin: 30px 0;
            border: 1px solid var(--color-border);
        }
        .blog-body pre code {
            background: none;
            padding: 0;
            color: var(--color-text);
        }
        .blog-body blockquote {
            border-left: 4px solid var(--color-secondary);
            padding-left: 25px;
            margin: 30px 0;
            font-style: italic;
            color: var(--color-text);
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            color: var(--color-primary);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 40px;
            transition: all var(--transition-normal);
        }
        .back-link:hover {
            gap: 15px;
        }
        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 30px 0;
        }
        .tech-tag {
            padding: 8px 16px;
            background: var(--gradient-card);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-full);
            font-size: 0.9rem;
            color: var(--color-text);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 40px 0;
        }
        .stat-card {
            background: var(--gradient-card);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 25px;
            text-align: center;
        }
        .stat-card .number {
            font-size: 2.5rem;
            font-weight: 800;
            background: var(--gradient-text);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .stat-card .label {
            font-size: 0.9rem;
            color: var(--color-text-secondary);
            margin-top: 5px;
        }
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="noise-overlay"></div>

    <nav class="nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-logo">AreeVee</a>
            <div class="nav-links">
                <a href="../index.html#about">About</a>
                <a href="../index.html#projects">Projects</a>
                <a href="../index.html#blog">Blog</a>
                <a href="../index.html#contact">Contact</a>
            </div>
        </div>
    </nav>

    <main>
        <article class="blog-post">
            <div class="container">
                <a href="../index.html#blog" class="back-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    Back to Articles
                </a>

                <header class="blog-header">
                    <span class="blog-category-tag">Backend</span>
                    <h1 class="blog-post-title">Scaling FastAPI for Millions of Records</h1>
                    <div class="blog-meta">
                        <span>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M12 6v6l4 2"/>
                            </svg>
                            12 min read
                        </span>
                        <span>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                                <line x1="16" y1="2" x2="16" y2="6"/>
                                <line x1="8" y1="2" x2="8" y2="6"/>
                                <line x1="3" y1="10" x2="21" y2="10"/>
                            </svg>
                            January 2025
                        </span>
                    </div>
                </header>

                <div class="blog-featured-image">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                        <polyline points="16 18 22 12 16 6"></polyline>
                        <polyline points="8 6 2 12 8 18"></polyline>
                    </svg>
                </div>

                <div class="blog-body">
                    <p>
                        When building a real-time trading analytics platform, performance isn't just a nice-to-have - it's essential. Traders need instant access to market data, and any delay can mean missed opportunities. Here's how we scaled our FastAPI backend to handle millions of records efficiently.
                    </p>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="number">5M+</div>
                            <div class="label">Records Processed Daily</div>
                        </div>
                        <div class="stat-card">
                            <div class="number">&lt;50ms</div>
                            <div class="label">Average Response Time</div>
                        </div>
                        <div class="stat-card">
                            <div class="number">99.9%</div>
                            <div class="label">Uptime SLA</div>
                        </div>
                    </div>

                    <h2>The Problem</h2>
                    <p>
                        Our trading platform needed to ingest real-time market data from multiple exchanges, process it, store it, and serve analytics queries - all with minimal latency. Initial benchmarks showed response times of 2-3 seconds for complex queries, which was unacceptable.
                    </p>

                    <h2>The Tech Stack</h2>
                    <div class="tech-stack">
                        <span class="tech-tag">FastAPI</span>
                        <span class="tech-tag">PostgreSQL</span>
                        <span class="tech-tag">TimescaleDB</span>
                        <span class="tech-tag">Redis</span>
                        <span class="tech-tag">Celery</span>
                        <span class="tech-tag">Docker</span>
                        <span class="tech-tag">Kubernetes</span>
                    </div>

                    <h2>Optimization Strategies</h2>

                    <h3>1. Async All The Way</h3>
                    <p>
                        FastAPI's async support is powerful, but only if you use it correctly. We ensured all I/O operations were truly async, from database queries to external API calls.
                    </p>

                    <pre><code>from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

async def get_trading_data(
    session: AsyncSession,
    symbol: str,
    start_date: datetime,
    end_date: datetime
) -> list[TradingRecord]:
    query = select(TradingRecord).where(
        TradingRecord.symbol == symbol,
        TradingRecord.timestamp.between(start_date, end_date)
    )
    result = await session.execute(query)
    return result.scalars().all()</code></pre>

                    <h3>2. Database Optimization with TimescaleDB</h3>
                    <p>
                        For time-series data, PostgreSQL alone wasn't enough. We integrated TimescaleDB, which automatically partitions data by time intervals and provides optimized queries for time-based analytics.
                    </p>

                    <pre><code>-- Convert regular table to hypertable
SELECT create_hypertable('trading_records', 'timestamp');

-- Create continuous aggregates for common queries
CREATE MATERIALIZED VIEW daily_ohlcv
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 day', timestamp) AS bucket,
    symbol,
    first(open, timestamp) AS open,
    max(high) AS high,
    min(low) AS low,
    last(close, timestamp) AS close,
    sum(volume) AS volume
FROM trading_records
GROUP BY bucket, symbol;</code></pre>

                    <h3>3. Strategic Caching with Redis</h3>
                    <p>
                        Not all data needs to be fetched from the database every time. We implemented a multi-layer caching strategy:
                    </p>
                    <ul>
                        <li><strong>Hot data cache:</strong> Frequently accessed symbols and recent data</li>
                        <li><strong>Computed aggregates:</strong> Pre-calculated statistics and metrics</li>
                        <li><strong>Query result cache:</strong> Results of expensive analytical queries</li>
                    </ul>

                    <pre><code>import redis.asyncio as redis
from fastapi_cache import FastAPICache
from fastapi_cache.decorator import cache

@app.get("/api/v1/analytics/{symbol}")
@cache(expire=60)  # Cache for 60 seconds
async def get_analytics(symbol: str):
    # This result will be cached
    return await compute_analytics(symbol)</code></pre>

                    <h3>4. Connection Pooling</h3>
                    <p>
                        Database connections are expensive. We configured connection pools carefully to balance between connection reuse and avoiding contention:
                    </p>

                    <pre><code>from sqlalchemy.ext.asyncio import create_async_engine

engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=10,
    pool_pre_ping=True,
    pool_recycle=3600
)</code></pre>

                    <h3>5. Background Processing with Celery</h3>
                    <p>
                        Heavy computations don't belong in request handlers. We offloaded complex analytics to Celery workers, allowing the API to respond quickly while processing happens in the background.
                    </p>

                    <blockquote>
                        "The fastest API call is the one that doesn't wait for heavy processing to complete."
                    </blockquote>

                    <h3>6. Efficient Serialization</h3>
                    <p>
                        JSON serialization can be a bottleneck when dealing with large datasets. We switched to <code>orjson</code> for a significant performance boost:
                    </p>

                    <pre><code>from fastapi.responses import ORJSONResponse

app = FastAPI(default_response_class=ORJSONResponse)</code></pre>

                    <h2>Results</h2>
                    <p>
                        After implementing these optimizations, we achieved:
                    </p>
                    <ul>
                        <li>Response times dropped from 2-3 seconds to under 50ms for most queries</li>
                        <li>Throughput increased by 10x, handling 1000+ requests per second</li>
                        <li>Database load reduced by 70% thanks to caching</li>
                        <li>99.9% uptime with automatic failover</li>
                    </ul>

                    <h2>Lessons Learned</h2>
                    <ol>
                        <li><strong>Measure before optimizing:</strong> Profile your code to find actual bottlenecks</li>
                        <li><strong>Choose the right database:</strong> TimescaleDB was a game-changer for our use case</li>
                        <li><strong>Cache strategically:</strong> Not everything needs caching, but the right things do</li>
                        <li><strong>Scale horizontally:</strong> Kubernetes made it easy to add more instances as needed</li>
                        <li><strong>Monitor everything:</strong> Prometheus and Grafana helped us catch issues early</li>
                    </ol>

                    <h2>Conclusion</h2>
                    <p>
                        Scaling FastAPI for millions of records is achievable with the right architecture and tools. The key is to understand your data access patterns and optimize accordingly. Don't prematurely optimize - measure, identify bottlenecks, and address them systematically.
                    </p>

                    <p>
                        If you're building high-performance APIs with Python, FastAPI is an excellent choice. Combined with async programming, proper database optimization, and strategic caching, you can build systems that rival those written in traditionally "faster" languages.
                    </p>
                </div>
            </div>
        </article>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <span class="footer-logo">AreeVee</span>
                    <p>Python Developer & Tech Lead building scalable solutions.</p>
                </div>
                <div class="footer-links">
                    <a href="../index.html#hero">Home</a>
                    <a href="../index.html#about">About</a>
                    <a href="../index.html#projects">Projects</a>
                    <a href="../index.html#contact">Contact</a>
                    <a href="https://linkedin.com/in/rathodvipul99" target="_blank" rel="noopener noreferrer">LinkedIn</a>
                    <a href="https://github.com/RathodVipul234" target="_blank" rel="noopener noreferrer">GitHub</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Vipul Rathod. All rights reserved.</p>
                <p>Built with passion and code.</p>
            </div>
        </div>
    </footer>
</body>
</html>
